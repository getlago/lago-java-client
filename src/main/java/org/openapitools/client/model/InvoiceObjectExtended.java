/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 0.46.0-beta
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.CreditObject;
import org.openapitools.client.model.Currency;
import org.openapitools.client.model.FeeObject;
import org.openapitools.client.model.InvoiceAppliedTaxObject;
import org.openapitools.client.model.InvoiceMetadataObject;
import org.openapitools.client.model.InvoiceObjectCustomer;
import org.openapitools.client.model.SubscriptionObject;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * InvoiceObjectExtended
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-08-31T09:24:39.843670Z[Etc/UTC]")
public class InvoiceObjectExtended {
  public static final String SERIALIZED_NAME_LAGO_ID = "lago_id";
  @SerializedName(SERIALIZED_NAME_LAGO_ID)
  private UUID lagoId;

  public static final String SERIALIZED_NAME_SEQUENTIAL_ID = "sequential_id";
  @SerializedName(SERIALIZED_NAME_SEQUENTIAL_ID)
  private Integer sequentialId;

  public static final String SERIALIZED_NAME_NUMBER = "number";
  @SerializedName(SERIALIZED_NAME_NUMBER)
  private String number;

  public static final String SERIALIZED_NAME_ISSUING_DATE = "issuing_date";
  @SerializedName(SERIALIZED_NAME_ISSUING_DATE)
  private LocalDate issuingDate;

  public static final String SERIALIZED_NAME_PAYMENT_DUE_DATE = "payment_due_date";
  @SerializedName(SERIALIZED_NAME_PAYMENT_DUE_DATE)
  private LocalDate paymentDueDate;

  public static final String SERIALIZED_NAME_NET_PAYMENT_TERM = "net_payment_term";
  @SerializedName(SERIALIZED_NAME_NET_PAYMENT_TERM)
  private Integer netPaymentTerm;

  /**
   * The type of invoice issued. Possible values are &#x60;subscription&#x60;, &#x60;one-off&#x60; or &#x60;credit&#x60;.
   */
  @JsonAdapter(InvoiceTypeEnum.Adapter.class)
  public enum InvoiceTypeEnum {
    SUBSCRIPTION("subscription"),
    
    ADD_ON("add_on"),
    
    CREDIT("credit"),
    
    ONE_OFF("one_off");

    private String value;

    InvoiceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InvoiceTypeEnum fromValue(String value) {
      for (InvoiceTypeEnum b : InvoiceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InvoiceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InvoiceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InvoiceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InvoiceTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_INVOICE_TYPE = "invoice_type";
  @SerializedName(SERIALIZED_NAME_INVOICE_TYPE)
  private InvoiceTypeEnum invoiceType;

  /**
   * The status of the invoice. It indicates the current state of the invoice and can have two possible values: - &#x60;draft&#x60;: the invoice is in the draft state, waiting for the end of the grace period to be finalized. During this period, events can still be ingested and added to the invoice. - &#x60;finalized&#x60;: the invoice has been issued and finalized. In this state, events cannot be ingested or added to the invoice anymore.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    DRAFT("draft"),
    
    FINALIZED("finalized");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  /**
   * The status of the payment associated with the invoice. It can have one of the following values: - &#x60;pending&#x60;: the payment is pending, waiting for payment processing in Stripe or when the invoice is emitted but users have not updated the payment status through the endpoint. - &#x60;succeeded&#x60;: the payment of the invoice has been successfully processed. - &#x60;failed&#x60;: the payment of the invoice has failed or encountered an error during processing.
   */
  @JsonAdapter(PaymentStatusEnum.Adapter.class)
  public enum PaymentStatusEnum {
    PENDING("pending"),
    
    SUCCEEDED("succeeded"),
    
    FAILED("failed");

    private String value;

    PaymentStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PaymentStatusEnum fromValue(String value) {
      for (PaymentStatusEnum b : PaymentStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PaymentStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PaymentStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PaymentStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PaymentStatusEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PAYMENT_STATUS = "payment_status";
  @SerializedName(SERIALIZED_NAME_PAYMENT_STATUS)
  private PaymentStatusEnum paymentStatus;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private Currency currency;

  public static final String SERIALIZED_NAME_FEES_AMOUNT_CENTS = "fees_amount_cents";
  @SerializedName(SERIALIZED_NAME_FEES_AMOUNT_CENTS)
  private Integer feesAmountCents;

  public static final String SERIALIZED_NAME_COUPONS_AMOUNT_CENTS = "coupons_amount_cents";
  @SerializedName(SERIALIZED_NAME_COUPONS_AMOUNT_CENTS)
  private Integer couponsAmountCents;

  public static final String SERIALIZED_NAME_CREDIT_NOTES_AMOUNT_CENTS = "credit_notes_amount_cents";
  @SerializedName(SERIALIZED_NAME_CREDIT_NOTES_AMOUNT_CENTS)
  private Integer creditNotesAmountCents;

  public static final String SERIALIZED_NAME_SUB_TOTAL_EXCLUDING_TAXES_AMOUNT_CENTS = "sub_total_excluding_taxes_amount_cents";
  @SerializedName(SERIALIZED_NAME_SUB_TOTAL_EXCLUDING_TAXES_AMOUNT_CENTS)
  private Integer subTotalExcludingTaxesAmountCents;

  public static final String SERIALIZED_NAME_TAXES_AMOUNT_CENTS = "taxes_amount_cents";
  @SerializedName(SERIALIZED_NAME_TAXES_AMOUNT_CENTS)
  private Integer taxesAmountCents;

  public static final String SERIALIZED_NAME_SUB_TOTAL_INCLUDING_TAXES_AMOUNT_CENTS = "sub_total_including_taxes_amount_cents";
  @SerializedName(SERIALIZED_NAME_SUB_TOTAL_INCLUDING_TAXES_AMOUNT_CENTS)
  private Integer subTotalIncludingTaxesAmountCents;

  public static final String SERIALIZED_NAME_PREPAID_CREDIT_AMOUNT_CENTS = "prepaid_credit_amount_cents";
  @SerializedName(SERIALIZED_NAME_PREPAID_CREDIT_AMOUNT_CENTS)
  private Integer prepaidCreditAmountCents;

  public static final String SERIALIZED_NAME_TOTAL_AMOUNT_CENTS = "total_amount_cents";
  @SerializedName(SERIALIZED_NAME_TOTAL_AMOUNT_CENTS)
  private Integer totalAmountCents;

  public static final String SERIALIZED_NAME_VERSION_NUMBER = "version_number";
  @SerializedName(SERIALIZED_NAME_VERSION_NUMBER)
  private Integer versionNumber;

  public static final String SERIALIZED_NAME_FILE_URL = "file_url";
  @SerializedName(SERIALIZED_NAME_FILE_URL)
  private URI fileUrl;

  public static final String SERIALIZED_NAME_CUSTOMER = "customer";
  @SerializedName(SERIALIZED_NAME_CUSTOMER)
  private InvoiceObjectCustomer customer;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private List<InvoiceMetadataObject> metadata;

  public static final String SERIALIZED_NAME_APPLIED_TAXES = "applied_taxes";
  @SerializedName(SERIALIZED_NAME_APPLIED_TAXES)
  private List<InvoiceAppliedTaxObject> appliedTaxes;

  public static final String SERIALIZED_NAME_CREDITS = "credits";
  @SerializedName(SERIALIZED_NAME_CREDITS)
  private List<CreditObject> credits;

  public static final String SERIALIZED_NAME_FEES = "fees";
  @SerializedName(SERIALIZED_NAME_FEES)
  private List<FeeObject> fees;

  public static final String SERIALIZED_NAME_SUBSCRIPTIONS = "subscriptions";
  @SerializedName(SERIALIZED_NAME_SUBSCRIPTIONS)
  private List<SubscriptionObject> subscriptions;

  public InvoiceObjectExtended() {
  }

  public InvoiceObjectExtended lagoId(UUID lagoId) {
    
    this.lagoId = lagoId;
    return this;
  }

   /**
   * Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the feeâ€™s record within the Lago system.
   * @return lagoId
  **/
  @javax.annotation.Nonnull
  public UUID getLagoId() {
    return lagoId;
  }


  public void setLagoId(UUID lagoId) {
    this.lagoId = lagoId;
  }


  public InvoiceObjectExtended sequentialId(Integer sequentialId) {
    
    this.sequentialId = sequentialId;
    return this;
  }

   /**
   * This ID helps in uniquely identifying and organizing the invoices associated with a specific customer. It provides a sequential numbering system specific to the customer, allowing for easy tracking and management of invoices within the customer&#39;s context.
   * @return sequentialId
  **/
  @javax.annotation.Nonnull
  public Integer getSequentialId() {
    return sequentialId;
  }


  public void setSequentialId(Integer sequentialId) {
    this.sequentialId = sequentialId;
  }


  public InvoiceObjectExtended number(String number) {
    
    this.number = number;
    return this;
  }

   /**
   * The unique number assigned to the invoice. This number serves as a distinct identifier for the invoice and helps in differentiating it from other invoices in the system.
   * @return number
  **/
  @javax.annotation.Nonnull
  public String getNumber() {
    return number;
  }


  public void setNumber(String number) {
    this.number = number;
  }


  public InvoiceObjectExtended issuingDate(LocalDate issuingDate) {
    
    this.issuingDate = issuingDate;
    return this;
  }

   /**
   * The date when the invoice was issued. It is provided in the ISO 8601 date format.
   * @return issuingDate
  **/
  @javax.annotation.Nonnull
  public LocalDate getIssuingDate() {
    return issuingDate;
  }


  public void setIssuingDate(LocalDate issuingDate) {
    this.issuingDate = issuingDate;
  }


  public InvoiceObjectExtended paymentDueDate(LocalDate paymentDueDate) {
    
    this.paymentDueDate = paymentDueDate;
    return this;
  }

   /**
   * The payment due date for the invoice, specified in the ISO 8601 date format.
   * @return paymentDueDate
  **/
  @javax.annotation.Nullable
  public LocalDate getPaymentDueDate() {
    return paymentDueDate;
  }


  public void setPaymentDueDate(LocalDate paymentDueDate) {
    this.paymentDueDate = paymentDueDate;
  }


  public InvoiceObjectExtended netPaymentTerm(Integer netPaymentTerm) {
    
    this.netPaymentTerm = netPaymentTerm;
    return this;
  }

   /**
   * The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.
   * @return netPaymentTerm
  **/
  @javax.annotation.Nullable
  public Integer getNetPaymentTerm() {
    return netPaymentTerm;
  }


  public void setNetPaymentTerm(Integer netPaymentTerm) {
    this.netPaymentTerm = netPaymentTerm;
  }


  public InvoiceObjectExtended invoiceType(InvoiceTypeEnum invoiceType) {
    
    this.invoiceType = invoiceType;
    return this;
  }

   /**
   * The type of invoice issued. Possible values are &#x60;subscription&#x60;, &#x60;one-off&#x60; or &#x60;credit&#x60;.
   * @return invoiceType
  **/
  @javax.annotation.Nonnull
  public InvoiceTypeEnum getInvoiceType() {
    return invoiceType;
  }


  public void setInvoiceType(InvoiceTypeEnum invoiceType) {
    this.invoiceType = invoiceType;
  }


  public InvoiceObjectExtended status(StatusEnum status) {
    
    this.status = status;
    return this;
  }

   /**
   * The status of the invoice. It indicates the current state of the invoice and can have two possible values: - &#x60;draft&#x60;: the invoice is in the draft state, waiting for the end of the grace period to be finalized. During this period, events can still be ingested and added to the invoice. - &#x60;finalized&#x60;: the invoice has been issued and finalized. In this state, events cannot be ingested or added to the invoice anymore.
   * @return status
  **/
  @javax.annotation.Nonnull
  public StatusEnum getStatus() {
    return status;
  }


  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  public InvoiceObjectExtended paymentStatus(PaymentStatusEnum paymentStatus) {
    
    this.paymentStatus = paymentStatus;
    return this;
  }

   /**
   * The status of the payment associated with the invoice. It can have one of the following values: - &#x60;pending&#x60;: the payment is pending, waiting for payment processing in Stripe or when the invoice is emitted but users have not updated the payment status through the endpoint. - &#x60;succeeded&#x60;: the payment of the invoice has been successfully processed. - &#x60;failed&#x60;: the payment of the invoice has failed or encountered an error during processing.
   * @return paymentStatus
  **/
  @javax.annotation.Nonnull
  public PaymentStatusEnum getPaymentStatus() {
    return paymentStatus;
  }


  public void setPaymentStatus(PaymentStatusEnum paymentStatus) {
    this.paymentStatus = paymentStatus;
  }


  public InvoiceObjectExtended currency(Currency currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * Get currency
   * @return currency
  **/
  @javax.annotation.Nonnull
  public Currency getCurrency() {
    return currency;
  }


  public void setCurrency(Currency currency) {
    this.currency = currency;
  }


  public InvoiceObjectExtended feesAmountCents(Integer feesAmountCents) {
    
    this.feesAmountCents = feesAmountCents;
    return this;
  }

   /**
   * The total sum of fees amount in cents. It calculates the cumulative amount of all the fees associated with the invoice, providing a consolidated value.
   * @return feesAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getFeesAmountCents() {
    return feesAmountCents;
  }


  public void setFeesAmountCents(Integer feesAmountCents) {
    this.feesAmountCents = feesAmountCents;
  }


  public InvoiceObjectExtended couponsAmountCents(Integer couponsAmountCents) {
    
    this.couponsAmountCents = couponsAmountCents;
    return this;
  }

   /**
   * The total sum of all coupons discounted on the invoice. It calculates the cumulative discount amount applied by coupons, expressed in cents.
   * @return couponsAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getCouponsAmountCents() {
    return couponsAmountCents;
  }


  public void setCouponsAmountCents(Integer couponsAmountCents) {
    this.couponsAmountCents = couponsAmountCents;
  }


  public InvoiceObjectExtended creditNotesAmountCents(Integer creditNotesAmountCents) {
    
    this.creditNotesAmountCents = creditNotesAmountCents;
    return this;
  }

   /**
   * The total sum of all credit notes discounted on the invoice. It calculates the cumulative discount amount applied by credit notes, expressed in cents.
   * @return creditNotesAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getCreditNotesAmountCents() {
    return creditNotesAmountCents;
  }


  public void setCreditNotesAmountCents(Integer creditNotesAmountCents) {
    this.creditNotesAmountCents = creditNotesAmountCents;
  }


  public InvoiceObjectExtended subTotalExcludingTaxesAmountCents(Integer subTotalExcludingTaxesAmountCents) {
    
    this.subTotalExcludingTaxesAmountCents = subTotalExcludingTaxesAmountCents;
    return this;
  }

   /**
   * Subtotal amount, excluding taxes, expressed in cents. This field depends on the version number. Here are the definitions based on the version: - Version 1: is equal to the sum of &#x60;fees_amount_cents&#x60;, minus &#x60;coupons_amount_cents&#x60;, and minus &#x60;prepaid_credit_amount_cents&#x60;. - Version 2: is equal to the &#x60;fees_amount_cents&#x60;. - Version 3: is equal to the &#x60;fees_amount_cents&#x60;, minus &#x60;coupons_amount_cents&#x60;
   * @return subTotalExcludingTaxesAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getSubTotalExcludingTaxesAmountCents() {
    return subTotalExcludingTaxesAmountCents;
  }


  public void setSubTotalExcludingTaxesAmountCents(Integer subTotalExcludingTaxesAmountCents) {
    this.subTotalExcludingTaxesAmountCents = subTotalExcludingTaxesAmountCents;
  }


  public InvoiceObjectExtended taxesAmountCents(Integer taxesAmountCents) {
    
    this.taxesAmountCents = taxesAmountCents;
    return this;
  }

   /**
   * The sum of tax amount associated with the invoice, expressed in cents.
   * @return taxesAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getTaxesAmountCents() {
    return taxesAmountCents;
  }


  public void setTaxesAmountCents(Integer taxesAmountCents) {
    this.taxesAmountCents = taxesAmountCents;
  }


  public InvoiceObjectExtended subTotalIncludingTaxesAmountCents(Integer subTotalIncludingTaxesAmountCents) {
    
    this.subTotalIncludingTaxesAmountCents = subTotalIncludingTaxesAmountCents;
    return this;
  }

   /**
   * Subtotal amount, including taxes, expressed in cents. This field depends on the version number. Here are the definitions based on the version: - Version 1: is equal to the &#x60;total_amount_cents&#x60;. - Version 2: is equal to the sum of &#x60;fees_amount_cents&#x60; and &#x60;taxes_amount_cents&#x60;. - Version 3: is equal to the sum &#x60;sub_total_excluding_taxes_amount_cents&#x60; and &#x60;taxes_amount_cents&#x60;
   * @return subTotalIncludingTaxesAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getSubTotalIncludingTaxesAmountCents() {
    return subTotalIncludingTaxesAmountCents;
  }


  public void setSubTotalIncludingTaxesAmountCents(Integer subTotalIncludingTaxesAmountCents) {
    this.subTotalIncludingTaxesAmountCents = subTotalIncludingTaxesAmountCents;
  }


  public InvoiceObjectExtended prepaidCreditAmountCents(Integer prepaidCreditAmountCents) {
    
    this.prepaidCreditAmountCents = prepaidCreditAmountCents;
    return this;
  }

   /**
   * The total sum of all prepaid credits discounted on the invoice. It calculates the cumulative discount amount applied by prepaid credits, expressed in cents.
   * @return prepaidCreditAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getPrepaidCreditAmountCents() {
    return prepaidCreditAmountCents;
  }


  public void setPrepaidCreditAmountCents(Integer prepaidCreditAmountCents) {
    this.prepaidCreditAmountCents = prepaidCreditAmountCents;
  }


  public InvoiceObjectExtended totalAmountCents(Integer totalAmountCents) {
    
    this.totalAmountCents = totalAmountCents;
    return this;
  }

   /**
   * The sum of the amount and taxes amount on the invoice, expressed in cents. It calculates the total financial value of the invoice, including both the original amount and any applicable taxes.
   * @return totalAmountCents
  **/
  @javax.annotation.Nonnull
  public Integer getTotalAmountCents() {
    return totalAmountCents;
  }


  public void setTotalAmountCents(Integer totalAmountCents) {
    this.totalAmountCents = totalAmountCents;
  }


  public InvoiceObjectExtended versionNumber(Integer versionNumber) {
    
    this.versionNumber = versionNumber;
    return this;
  }

   /**
   * Get versionNumber
   * @return versionNumber
  **/
  @javax.annotation.Nonnull
  public Integer getVersionNumber() {
    return versionNumber;
  }


  public void setVersionNumber(Integer versionNumber) {
    this.versionNumber = versionNumber;
  }


  public InvoiceObjectExtended fileUrl(URI fileUrl) {
    
    this.fileUrl = fileUrl;
    return this;
  }

   /**
   * Contains the URL that provides direct access to the invoice PDF file. You can use this URL to download or view the PDF document of the invoice
   * @return fileUrl
  **/
  @javax.annotation.Nullable
  public URI getFileUrl() {
    return fileUrl;
  }


  public void setFileUrl(URI fileUrl) {
    this.fileUrl = fileUrl;
  }


  public InvoiceObjectExtended customer(InvoiceObjectCustomer customer) {
    
    this.customer = customer;
    return this;
  }

   /**
   * Get customer
   * @return customer
  **/
  @javax.annotation.Nullable
  public InvoiceObjectCustomer getCustomer() {
    return customer;
  }


  public void setCustomer(InvoiceObjectCustomer customer) {
    this.customer = customer;
  }


  public InvoiceObjectExtended metadata(List<InvoiceMetadataObject> metadata) {
    
    this.metadata = metadata;
    return this;
  }

  public InvoiceObjectExtended addMetadataItem(InvoiceMetadataObject metadataItem) {
    if (this.metadata == null) {
      this.metadata = new ArrayList<>();
    }
    this.metadata.add(metadataItem);
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @javax.annotation.Nullable
  public List<InvoiceMetadataObject> getMetadata() {
    return metadata;
  }


  public void setMetadata(List<InvoiceMetadataObject> metadata) {
    this.metadata = metadata;
  }


  public InvoiceObjectExtended appliedTaxes(List<InvoiceAppliedTaxObject> appliedTaxes) {
    
    this.appliedTaxes = appliedTaxes;
    return this;
  }

  public InvoiceObjectExtended addAppliedTaxesItem(InvoiceAppliedTaxObject appliedTaxesItem) {
    if (this.appliedTaxes == null) {
      this.appliedTaxes = new ArrayList<>();
    }
    this.appliedTaxes.add(appliedTaxesItem);
    return this;
  }

   /**
   * Get appliedTaxes
   * @return appliedTaxes
  **/
  @javax.annotation.Nullable
  public List<InvoiceAppliedTaxObject> getAppliedTaxes() {
    return appliedTaxes;
  }


  public void setAppliedTaxes(List<InvoiceAppliedTaxObject> appliedTaxes) {
    this.appliedTaxes = appliedTaxes;
  }


  public InvoiceObjectExtended credits(List<CreditObject> credits) {
    
    this.credits = credits;
    return this;
  }

  public InvoiceObjectExtended addCreditsItem(CreditObject creditsItem) {
    if (this.credits == null) {
      this.credits = new ArrayList<>();
    }
    this.credits.add(creditsItem);
    return this;
  }

   /**
   * Get credits
   * @return credits
  **/
  @javax.annotation.Nullable
  public List<CreditObject> getCredits() {
    return credits;
  }


  public void setCredits(List<CreditObject> credits) {
    this.credits = credits;
  }


  public InvoiceObjectExtended fees(List<FeeObject> fees) {
    
    this.fees = fees;
    return this;
  }

  public InvoiceObjectExtended addFeesItem(FeeObject feesItem) {
    if (this.fees == null) {
      this.fees = new ArrayList<>();
    }
    this.fees.add(feesItem);
    return this;
  }

   /**
   * Get fees
   * @return fees
  **/
  @javax.annotation.Nullable
  public List<FeeObject> getFees() {
    return fees;
  }


  public void setFees(List<FeeObject> fees) {
    this.fees = fees;
  }


  public InvoiceObjectExtended subscriptions(List<SubscriptionObject> subscriptions) {
    
    this.subscriptions = subscriptions;
    return this;
  }

  public InvoiceObjectExtended addSubscriptionsItem(SubscriptionObject subscriptionsItem) {
    if (this.subscriptions == null) {
      this.subscriptions = new ArrayList<>();
    }
    this.subscriptions.add(subscriptionsItem);
    return this;
  }

   /**
   * Get subscriptions
   * @return subscriptions
  **/
  @javax.annotation.Nullable
  public List<SubscriptionObject> getSubscriptions() {
    return subscriptions;
  }


  public void setSubscriptions(List<SubscriptionObject> subscriptions) {
    this.subscriptions = subscriptions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InvoiceObjectExtended invoiceObjectExtended = (InvoiceObjectExtended) o;
    return Objects.equals(this.lagoId, invoiceObjectExtended.lagoId) &&
        Objects.equals(this.sequentialId, invoiceObjectExtended.sequentialId) &&
        Objects.equals(this.number, invoiceObjectExtended.number) &&
        Objects.equals(this.issuingDate, invoiceObjectExtended.issuingDate) &&
        Objects.equals(this.paymentDueDate, invoiceObjectExtended.paymentDueDate) &&
        Objects.equals(this.netPaymentTerm, invoiceObjectExtended.netPaymentTerm) &&
        Objects.equals(this.invoiceType, invoiceObjectExtended.invoiceType) &&
        Objects.equals(this.status, invoiceObjectExtended.status) &&
        Objects.equals(this.paymentStatus, invoiceObjectExtended.paymentStatus) &&
        Objects.equals(this.currency, invoiceObjectExtended.currency) &&
        Objects.equals(this.feesAmountCents, invoiceObjectExtended.feesAmountCents) &&
        Objects.equals(this.couponsAmountCents, invoiceObjectExtended.couponsAmountCents) &&
        Objects.equals(this.creditNotesAmountCents, invoiceObjectExtended.creditNotesAmountCents) &&
        Objects.equals(this.subTotalExcludingTaxesAmountCents, invoiceObjectExtended.subTotalExcludingTaxesAmountCents) &&
        Objects.equals(this.taxesAmountCents, invoiceObjectExtended.taxesAmountCents) &&
        Objects.equals(this.subTotalIncludingTaxesAmountCents, invoiceObjectExtended.subTotalIncludingTaxesAmountCents) &&
        Objects.equals(this.prepaidCreditAmountCents, invoiceObjectExtended.prepaidCreditAmountCents) &&
        Objects.equals(this.totalAmountCents, invoiceObjectExtended.totalAmountCents) &&
        Objects.equals(this.versionNumber, invoiceObjectExtended.versionNumber) &&
        Objects.equals(this.fileUrl, invoiceObjectExtended.fileUrl) &&
        Objects.equals(this.customer, invoiceObjectExtended.customer) &&
        Objects.equals(this.metadata, invoiceObjectExtended.metadata) &&
        Objects.equals(this.appliedTaxes, invoiceObjectExtended.appliedTaxes) &&
        Objects.equals(this.credits, invoiceObjectExtended.credits) &&
        Objects.equals(this.fees, invoiceObjectExtended.fees) &&
        Objects.equals(this.subscriptions, invoiceObjectExtended.subscriptions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(lagoId, sequentialId, number, issuingDate, paymentDueDate, netPaymentTerm, invoiceType, status, paymentStatus, currency, feesAmountCents, couponsAmountCents, creditNotesAmountCents, subTotalExcludingTaxesAmountCents, taxesAmountCents, subTotalIncludingTaxesAmountCents, prepaidCreditAmountCents, totalAmountCents, versionNumber, fileUrl, customer, metadata, appliedTaxes, credits, fees, subscriptions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InvoiceObjectExtended {\n");
    sb.append("    lagoId: ").append(toIndentedString(lagoId)).append("\n");
    sb.append("    sequentialId: ").append(toIndentedString(sequentialId)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("    issuingDate: ").append(toIndentedString(issuingDate)).append("\n");
    sb.append("    paymentDueDate: ").append(toIndentedString(paymentDueDate)).append("\n");
    sb.append("    netPaymentTerm: ").append(toIndentedString(netPaymentTerm)).append("\n");
    sb.append("    invoiceType: ").append(toIndentedString(invoiceType)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    paymentStatus: ").append(toIndentedString(paymentStatus)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    feesAmountCents: ").append(toIndentedString(feesAmountCents)).append("\n");
    sb.append("    couponsAmountCents: ").append(toIndentedString(couponsAmountCents)).append("\n");
    sb.append("    creditNotesAmountCents: ").append(toIndentedString(creditNotesAmountCents)).append("\n");
    sb.append("    subTotalExcludingTaxesAmountCents: ").append(toIndentedString(subTotalExcludingTaxesAmountCents)).append("\n");
    sb.append("    taxesAmountCents: ").append(toIndentedString(taxesAmountCents)).append("\n");
    sb.append("    subTotalIncludingTaxesAmountCents: ").append(toIndentedString(subTotalIncludingTaxesAmountCents)).append("\n");
    sb.append("    prepaidCreditAmountCents: ").append(toIndentedString(prepaidCreditAmountCents)).append("\n");
    sb.append("    totalAmountCents: ").append(toIndentedString(totalAmountCents)).append("\n");
    sb.append("    versionNumber: ").append(toIndentedString(versionNumber)).append("\n");
    sb.append("    fileUrl: ").append(toIndentedString(fileUrl)).append("\n");
    sb.append("    customer: ").append(toIndentedString(customer)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    appliedTaxes: ").append(toIndentedString(appliedTaxes)).append("\n");
    sb.append("    credits: ").append(toIndentedString(credits)).append("\n");
    sb.append("    fees: ").append(toIndentedString(fees)).append("\n");
    sb.append("    subscriptions: ").append(toIndentedString(subscriptions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("lago_id");
    openapiFields.add("sequential_id");
    openapiFields.add("number");
    openapiFields.add("issuing_date");
    openapiFields.add("payment_due_date");
    openapiFields.add("net_payment_term");
    openapiFields.add("invoice_type");
    openapiFields.add("status");
    openapiFields.add("payment_status");
    openapiFields.add("currency");
    openapiFields.add("fees_amount_cents");
    openapiFields.add("coupons_amount_cents");
    openapiFields.add("credit_notes_amount_cents");
    openapiFields.add("sub_total_excluding_taxes_amount_cents");
    openapiFields.add("taxes_amount_cents");
    openapiFields.add("sub_total_including_taxes_amount_cents");
    openapiFields.add("prepaid_credit_amount_cents");
    openapiFields.add("total_amount_cents");
    openapiFields.add("version_number");
    openapiFields.add("file_url");
    openapiFields.add("customer");
    openapiFields.add("metadata");
    openapiFields.add("applied_taxes");
    openapiFields.add("credits");
    openapiFields.add("fees");
    openapiFields.add("subscriptions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("lago_id");
    openapiRequiredFields.add("sequential_id");
    openapiRequiredFields.add("number");
    openapiRequiredFields.add("issuing_date");
    openapiRequiredFields.add("invoice_type");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("payment_status");
    openapiRequiredFields.add("currency");
    openapiRequiredFields.add("fees_amount_cents");
    openapiRequiredFields.add("coupons_amount_cents");
    openapiRequiredFields.add("credit_notes_amount_cents");
    openapiRequiredFields.add("sub_total_excluding_taxes_amount_cents");
    openapiRequiredFields.add("taxes_amount_cents");
    openapiRequiredFields.add("sub_total_including_taxes_amount_cents");
    openapiRequiredFields.add("prepaid_credit_amount_cents");
    openapiRequiredFields.add("total_amount_cents");
    openapiRequiredFields.add("version_number");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to InvoiceObjectExtended
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!InvoiceObjectExtended.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in InvoiceObjectExtended is not found in the empty JSON string", InvoiceObjectExtended.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!InvoiceObjectExtended.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `InvoiceObjectExtended` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : InvoiceObjectExtended.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("lago_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lago_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lago_id").toString()));
      }
      if (!jsonObj.get("number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("number").toString()));
      }
      if (!jsonObj.get("invoice_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `invoice_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("invoice_type").toString()));
      }
      if (!jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (!jsonObj.get("payment_status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `payment_status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("payment_status").toString()));
      }
      // validate the required field `currency`
      Currency.validateJsonElement(jsonObj.get("currency"));
      if ((jsonObj.get("file_url") != null && !jsonObj.get("file_url").isJsonNull()) && !jsonObj.get("file_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `file_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("file_url").toString()));
      }
      // validate the optional field `customer`
      if (jsonObj.get("customer") != null && !jsonObj.get("customer").isJsonNull()) {
        InvoiceObjectCustomer.validateJsonElement(jsonObj.get("customer"));
      }
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        JsonArray jsonArraymetadata = jsonObj.getAsJsonArray("metadata");
        if (jsonArraymetadata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metadata").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metadata` to be an array in the JSON string but got `%s`", jsonObj.get("metadata").toString()));
          }

          // validate the optional field `metadata` (array)
          for (int i = 0; i < jsonArraymetadata.size(); i++) {
            InvoiceMetadataObject.validateJsonElement(jsonArraymetadata.get(i));
          };
        }
      }
      if (jsonObj.get("applied_taxes") != null && !jsonObj.get("applied_taxes").isJsonNull()) {
        JsonArray jsonArrayappliedTaxes = jsonObj.getAsJsonArray("applied_taxes");
        if (jsonArrayappliedTaxes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("applied_taxes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `applied_taxes` to be an array in the JSON string but got `%s`", jsonObj.get("applied_taxes").toString()));
          }

          // validate the optional field `applied_taxes` (array)
          for (int i = 0; i < jsonArrayappliedTaxes.size(); i++) {
            InvoiceAppliedTaxObject.validateJsonElement(jsonArrayappliedTaxes.get(i));
          };
        }
      }
      if (jsonObj.get("credits") != null && !jsonObj.get("credits").isJsonNull()) {
        JsonArray jsonArraycredits = jsonObj.getAsJsonArray("credits");
        if (jsonArraycredits != null) {
          // ensure the json data is an array
          if (!jsonObj.get("credits").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `credits` to be an array in the JSON string but got `%s`", jsonObj.get("credits").toString()));
          }

          // validate the optional field `credits` (array)
          for (int i = 0; i < jsonArraycredits.size(); i++) {
            CreditObject.validateJsonElement(jsonArraycredits.get(i));
          };
        }
      }
      if (jsonObj.get("fees") != null && !jsonObj.get("fees").isJsonNull()) {
        JsonArray jsonArrayfees = jsonObj.getAsJsonArray("fees");
        if (jsonArrayfees != null) {
          // ensure the json data is an array
          if (!jsonObj.get("fees").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `fees` to be an array in the JSON string but got `%s`", jsonObj.get("fees").toString()));
          }

          // validate the optional field `fees` (array)
          for (int i = 0; i < jsonArrayfees.size(); i++) {
            FeeObject.validateJsonElement(jsonArrayfees.get(i));
          };
        }
      }
      if (jsonObj.get("subscriptions") != null && !jsonObj.get("subscriptions").isJsonNull()) {
        JsonArray jsonArraysubscriptions = jsonObj.getAsJsonArray("subscriptions");
        if (jsonArraysubscriptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("subscriptions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `subscriptions` to be an array in the JSON string but got `%s`", jsonObj.get("subscriptions").toString()));
          }

          // validate the optional field `subscriptions` (array)
          for (int i = 0; i < jsonArraysubscriptions.size(); i++) {
            SubscriptionObject.validateJsonElement(jsonArraysubscriptions.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!InvoiceObjectExtended.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'InvoiceObjectExtended' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<InvoiceObjectExtended> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(InvoiceObjectExtended.class));

       return (TypeAdapter<T>) new TypeAdapter<InvoiceObjectExtended>() {
           @Override
           public void write(JsonWriter out, InvoiceObjectExtended value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public InvoiceObjectExtended read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of InvoiceObjectExtended given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of InvoiceObjectExtended
  * @throws IOException if the JSON string is invalid with respect to InvoiceObjectExtended
  */
  public static InvoiceObjectExtended fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, InvoiceObjectExtended.class);
  }

 /**
  * Convert an instance of InvoiceObjectExtended to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

